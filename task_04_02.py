"""
Задача №2.

Напишите функцию http_headers_to_json, которая принимает два аргумента:
- путь к файлу с HTTP заголовками
- путь к файлу с результатами (в формате JSON)
Функция выполняет конвертирование HTTP-заголовков в формат JSON.
Ключами в JSON-объекте становятся имена заголовков, а значениями - значения заголовков.
Так же в JSON попадает дополнительная информация, в зависимости от вида заголовка.

HTTP-заголовки протокола версии 1.0/1.1 делятся на два вида: заголовки запроса и заголовки ответа.
В заголовках запроса первая строка имеет вид: "Метод URI Протокол/Версия" - GET / HTTP/1.1
В заголовках ответа первая строка имеет вид: "Протокол/версия Код Сообщение" - HTTP/1.1 200 OK
Со второй строки и до символов \n\n перечисляются сами заголовки со значениями.

Формат HTTP-заголовков следующий:
- заголовки отделяются друг от друга символом \n (переносом строки)
- имя заголовка и значение заголовка отделяются двоеточием

Если на входе файл с заголовком запроса, то в JSON файле должны быть ключи: "method", "uri", "protocol"
Если на входе файл с заголовком ответа, то в JSON файле должны быть ключи: "protocol", "status_code", "status_message"

(!) В выходном файле в значении заголовка не должно быть пробелов в начале и в конце строки

Подсказки:
1. Заголовки ответа всегда начинаются на "HTTP/", таким образом их легко отличить от заголовков запроса
2. В значениях заголовков может присутствовать двоеточие
3. Входной файл может заканчиваться переносом строки - \n (как в примерах)
4. В тестах не будет протокола HTTP2, где статусное сообщение было удалено из заголовков ответа.

Требуется реализовать только функцию, решение не должно осуществлять операций ввода-вывода.
Имя файла: task_04_02.py
Имя функции: http_headers_to_json
Тестовый набор данных №1:
Входной файл: headers-1.txt
Выходной файл: results-1.json
Тестовый набор данных №2:
Входной файл: headers-2.txt
Выходной файл: results-2.json
"""



import json

def http_headers_to_json(fin, fout):
    with open(fin) as fd:
        row = fd.readline().strip().split()
        row1 = row[0][0:3]
        if row1 == 'HTT':
            dic = {
            'protocol':row[0],
            'status_code':row[1],
            'status_message':row[2]            
            }
        
        if row1 == 'GET':
            dic = {
            'method': row[0], 
            'uri': row[1], 
            'protocol': row[2]
            }   
      
        for row in fd:
            row = row.strip('\n')
            row = fd.readline().strip().split(':', 1)
            if len(row) > 1:
                dic[row[0]] = row[1]
    
    with open(fout, 'w') as f:
        f.write(json.dumps(dic, indent=4))
            
    return dic

"""
    dic = {}
    if row1.find('HTTP/'):
        rows = f.readlines()
        for i in rows:
            i = i.strip('/n')
            key = i.split(':')[0]
            value = i.split(':')
            dic[key] = value 
        json.dump(dic, fz1, indent=4)

    
    
    rows = f.readlines()    
"""    



#print(http_headers_to_json('headers-2.txt', 'results-2.json'))
#print(http_headers_to_json('headers-3.txt', 'results-3.json'))
